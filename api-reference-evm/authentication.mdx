---
title: "Authentication"
description: "Guide to authenticating Orderly API endpoints"
---

All requests need to be signed using `orderly-key` and `orderly-secret`.

## Request Signature Example

Orderly Network uses the `ed25519` algorithm for general system access. Here we provide a simple example that shows you how to send a valid request to Orderly Network.

Assume the following information:

| Key                   | Value                                                                                                                              | Description                                               |
|-----------------------|------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| `orderly-account-id`  | `testuser.near`                                                                                                                    | NEAR Wallet Account id                                    |
| `orderly-key`         | `ed25519:8tm7dnKYkSc3FzgPuJaw1wztr79eeZpN35nHW5pL5XhX`                                                                             | retrieve from WOOFi DEX GUI                               |
| `orderly-secret`      | `ed25519:VNX6EELQhP4G4Zg8HtTNKjBJoCmMKFQ8es7D33NwauX49eoBiL1GUjBARcMGKPtdjFhWNF36SoCUTzJRWKn789B`                                  | retrieve from WOOFi DEX GUI                               |
| `orderly-trading-key` | `90b8d328cde365b3dd10b194048b677d575c2faf51790ecfa6c2fe8b0403324984b275e7bf4c486b4d713576cf20335e1230537c47aafdde0bd646af9b83a8d6` | retrieve from WOOFi DEX GUI (required for order requests) |
| `timestamp`           | `1649920583000`                                                                                                                    | Unix epoch time in milliseconds                           |

Note you must generate the order signature first to complete the full request before you can sign the request itself. 

Hash your request parameters with `orderly-secret`. The hashing logic is as below: 

**If the request looks like (details on how to generate the order signature can be found above):**

```json
POST /v1/order

# Body json:
{
  "symbol":"SPOT_NEAR_USDC",
  "order_type":"LIMIT",
  "order_price":15.23,
  "order_quantity":23.11,
  "side":"BUY",
  "signature": "fc3c41d988dd03a65a99354a7b1d311a43de6b7a7867bdbdaf228bb74a121f8e47bb15ff7f69eb19c96da222f651da53b5ab30fb7caf69a76f01ad9af06c154400"
}
```

First, normalize the request content:

1. Take the `timestamp` of the request
2. Concatenate it with the **request method** and **request path**
3. If the request body is not empty, concatenate the request body json by stringifying the json body.

**Normalize request content, The result content would look like following**

```
1649920583000POST/v1/order{"symbol": "SPOT_NEAR_USDC", "order_type": "LIMIT", "order_price": 15.23, "order_quantity": 23.11, "side": "BUY", "signature": "fc3c41d988dd03a65a99354a7b1d311a43de6b7a7867bdbdaf228bb74a121f8e47bb15ff7f69eb19c96da222f651da53b5ab30fb7caf69a76f01ad9af06c154400"}
```

**Then use `orderly-secret` to generate a signature using the `ed25519` algorithm, and encode the signature in base64 url format:**

<CodeGroup>
```java Java Example

// dependencies
org.bitcoinj:bitcoinj-core:0.15.9
org.bouncycastle:bcprov-jdk15to18:1.70

// Here are public/private key strings in FrontEnd 
// private key string ed25519:VNX6EELQhP4G4Zg8HtTNKjBJoCmMKFQ8es7D33NwauX49eoBiL1GUjBARcMGKPtdjFhWNF36SoCUTzJRWKn789B
// public key string ed25519:8tm7dnKYkSc3FzgPuJaw1wztr79eeZpN35nHW5pL5XhX
String privateKey = "VNX6EELQhP4G4Zg8HtTNKjBJoCmMKFQ8es7D33NwauX49eoBiL1GUjBARcMGKPtdjFhWNF36SoCUTzJRWKn789B";
String publicKey = "8tm7dnKYkSc3FzgPuJaw1wztr79eeZpN35nHW5pL5XhX";


//1. Decoded it into bytes array
byte[] privateBytes = Base58.decode(privateKey);
byte[] publicBytes = Base58.decode(publicKey);

The length of privateBytes is 64ï¼Œ and the length of publicBytes is 32. As we know both public/private key in ed25519 should be 32. We find out the privateBytes[32-63] equals to publicBytes[0-31].

//2. build private/public Key from the bytes array. In Java we use bcprov-jdk15to18.
// use the first 32 bytes to build privateKey
Ed25519PrivateKeyParameters privateKeyParameters = new Ed25519PrivateKeyParameters(privateBytes, 0);
Ed25519PublicKeyParameters publicKeyParameters = new Ed25519PublicKeyParameters(publicBytes);

//3. generate signature and encode it into URLSAFE Base64 (RFC4648, the '+' and '/' changed to '-' and '_' )
public static String sign(Ed25519PrivateKeyParameters privateKey, String message) throws CryptoException {
        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);
        Signer signer = new Ed25519Signer();
        signer.init(true, privateKey);
        signer.update(messageBytes, 0, messageBytes.length);
        byte[] signature = signer.generateSignature();
        return Base64.getUrlEncoder().encodeToString(signature);
    }

//4. verify signature with public key
public static boolean verify(Ed25519PublicKeyParameters publicKey, String message, String signature) {
        byte[] messageBytes = message.getBytes(StandardCharsets.UTF_8);
        byte[] signatureBytes = Base64.getUrlDecoder().decode(signature);

        Signer verifier = new Ed25519Signer();
        verifier.init(false, publicKey);
        verifier.update(messageBytes, 0, messageBytes.length);
        return verifier.verifySignature(signatureBytes);
    }

//5. example
String message = "1649920583000POST/v1/order{"symbol": "SPOT_NEAR_USDC", "order_type": "LIMIT", "order_price": 15.23, "order_quantity": 23.11,"side": "BUY", "signature": "fc3c41d988dd03a65a99354a7b1d311a43de6b7a7867bdbdaf228bb74a121f8e47bb15ff7f69eb19c96da222f651da53b5ab30fb7caf69a76f01ad9af06c154400"}";
String sign = sign(privateKeyParameters, message);
boolean verify = verify(publicKeyParameters, message, sign);

The signature is txU4R7Iw8iucV+gRCC/QxCrhevnCMyvnde34N8delsVHkFAJ3861M412PwE6ELI6m8LvqJdDjfA0dJ/EdJdQDw==
```

```python request_signature.py
from requests import Request
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
import datetime, json, base64, base58

def sign_request(self, request: Request, account_id: str, orderly_key: str, orderly_secret: str, trading_key: str):
  prepared = request.prepare()
  ts = round(datetime.datetime.now().timestamp() * 1000)

  json_str = ''
  if request.json is not None:
      json_str = json.dumps(request.json)
      
  orderly_private_key = Ed25519PrivateKey.from_private_bytes(base58.b58decode(orderly_secret)[0:32])

  signature_string = f"{ts}{request.method}{prepared.path_url}{json_str}"
  data_bytes = bytes(signature_string, 'utf-8')

  request_signature = base64.b64encode(orderly_private_key.sign(data_bytes)).decode("utf-8")

  request.headers['orderly-account-id'] = account_id
  request.headers['orderly-key'] = f'ed25519:{orderly_key}'
  request.headers['orderly-signature'] = request_signature
  request.headers['orderly-trading-key'] = trading_key
  request.headers['orderly-timestamp'] = str(ts)
  request.headers['Content-Type'] = 'application/json' if request.json else 'application/x-www-form-urlencoded'
  request.headers['Cache-Control'] = 'no-cache'
  
  return request
```

```javascript RequestSignature.js
const base64url = function (aStr: string) {
    return aStr.replace(/\+/g, '-').replace(/\//g, '_');
};
const signMessageByOrderlyKey = (params: string, keyPair: KeyPair) => {
    const u8 = Buffer.from(params);
    const signStr = keyPair.sign(u8);
    return base64url(Buffer.from(signStr.signature).toString('base64'));
}

const getOrderlySignature = async (url: string, method: MethodTypeEnum, params?: null | { [key: string]: string }): Promise<{ [key: string]: string }> => {
    const accountId = 'neardapp-t1.testnet';
    const urlParam = url.split(environment.config.apiUrl)[1];
    const timestamp = new Date().getTime().toString();
    let messageStr = [timestamp, method.toUpperCase(), urlParam].join('');
    if (params && Object.keys(params).length) {
        messageStr += JSON.stringify(params);
    }
    const keyPair = await environment.nearWalletConfig.keyStore.getKey(environment.nearWalletConfig.networkId, accountId)
    const sign = signMessageByOrderlyKey(messageStr, keyPair);

    return {
        'orderly-account-id': accountId,
        'orderly-key': keyPair?.getPublicKey().toString(),
        'orderly-timestamp': timestamp,
        'orderly-signature': sign,
    };
}
```
</CodeGroup>

Put the **signature** in request header as `orderly-signature`, **timestamp** as `orderly-timestamp`, and **orderly key** as `orderly-key`. Add the `orderly-trading-key` in the request header if you are performing a trading action.

**So the final request would look like:**

```sh
POST /v1/order HTTP/1.1
Content-Type: application/json
orderly-account-id: testuser.near
orderly-key: ed25519:8tm7dnKYkSc3FzgPuJaw1wztr79eeZpN35nHW5pL5XhX
orderly-trading-key: 90b8d328cde365b3dd10b194048b677d575c2faf51790ecfa6c2fe8b0403324984b275e7bf4c486b4d713576cf20335e1230537c47aafdde0bd646af9b83a8d6
orderly-signature: Z8ZgTnmMcKdfQBW62bLNON2YtMpz9riPvw-V33J3aA7_5VjaKehkQD06iAiagIMxja59bqp9L8zTLGXtBkHCCA==
orderly-timestamp: 1649920583000

{
  "symbol":"SPOT_NEAR_USDC",
  "order_type":"LIMIT",
  "order_price":15.23,
  "order_quantity":23.11,
  "side":"BUY",
  "signature":"fc3c41d988dd03a65a99354a7b1d311a43de6b7a7867bdbdaf228bb74a121f8e47bb15ff7f69eb19c96da222f651da53b5ab30fb7caf69a76f01ad9af06c154400"
}
```

## Security

There have three layer checker to check if a request is valid. Orderly server only accepts the request that passes all checkers. The checker contains the following:

**Request Timestamp checker:**  
The request would be considered expired and get rejected if the timestamp in `orderly-timestamp` header have 300+ seconds difference from the API server time.

**HMAC Parameter Signature:**  
The request must have a `orderly-signature` header that is generate from request parameters and signed with your Orderly secret key.

**Orderly Key Validity Check:**
The request must have an orderly-key header, and the orderly-key has to be added to the network via the Add Key functionality, matched with the account and is still valid (not expired yet).

**Order Parameter Signature:**  
Each order must have a `signature` parameter that is generated from order parameters and signed with your Orderly trading secret key. This is used to verify each order on chain.
